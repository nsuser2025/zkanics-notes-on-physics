<p>
<u>ATAT インストール</u></br>
事前に HOME/ATAT/3.50/bin のディレクトリを作っておく.</br>
makefile の BINDIR=HOME/ATAT/3.50/bin にする.</br>
make & make install
</p>

---

#### mcsqs
<p>
定義されたスーパーセルを用いて, モンテカルロ法から SQS を探索する.  
</p>

<p>
SQS に含まれる原子数（XX）は, rndstr.in で定義されたサイト数の倍数であり,
なおかつ全ての元素の原子数が整数になるような値にする.
例えば, 三元系の等原子組成 L1${_2}$ 合金（rndstr.in では4サイト）の場合,
SQS には少なくとも 12 個の原子が含まれている必要があります.

mcsqs コマンドは、材料の複雑さやカットオフ値の設定によっては無限に走り続けることがあります。
通常、カットオフには第2近接シェルまで含めるべきですが、それ以上含める必要はほとんどありません。
なぜなら、もし第2シェルの相関関数の不一致（ミスマッチ）が完璧でない場合、
その誤差がより外側のシェルの誤差を圧倒してしまう可能性が高いからです。

二元系合金の SQS は数秒で探索できるが, 五元系ランダム合金では,
Perfect_match SQS は見つからない可能性もある.
それどころか, 目的関数が十分低い SQS を見つけるだけでも数日から数週間かかることもある.
どんな構造を SQS として取り出すかの明確な基準はないが,
格子ベクトルが非常に長く, ベクトル間の角度が非常に小さい SQS は DFT
計算を行うモデルとして適していないから使わないほうがいい.  
</p>

#### sqscell.out を用いた探索

<p>
SQSの形状を制御することも可能です。
ここで、もう一つ注意を払うべきファイルがあります。
それが sqscell.out です。
このファイルは mcsqs コマンドによって生成されます。
典型的な sqscell.out の内容は以下の通りです：</br>
2</br>
</br>
 3 -2  4</br>
 3 -4  2</br>
-2  4 -3</br>
</br>
 3  0  0</br>
 0  3  0</br>
-1 -2  2</br>
</p>

<p>
最初の行はセル形状の総数を示し、その後に空行が続きます。次の3行は SQS の1つのセル形状を定義します。
この 3x3 行列はデカルト座標（Cartesian coordinates）を使用しており、
rndstr.in のユニットセルで表現されたものではないことに注意してください。
もし SQS に使用する正確なセルを固定したい場合は、
その格子ベクトルを sqscell.out に記述します。
これにより、mcsqs コマンドにパラメータを追加することで（これは -n xx パラメータを上書きします）、
SQS の生成を制限することができます。:mcsqs -rc  
</p>

<p>
2x2x2のFCCスーパーセル（32原子）を構築する場合、
sqscell.out に記述する行列は非常にシンプルで直感的なものになります。</br>  
1</br>
</br>
2 0 0</br>
0 2 0</br>
0 0 2</br>
</p>

---

#### Search for SQS with equi-length vectors
<p>
SQS の形状を制御する最も大きな理由は、その形状を可能な限り立方体に近づけることにあります。
これにより、DFT 計算において等方的な K 点（K-points）の設定が可能になり,
対称性に関連するトラブルも少なくなります。
これは、ユーザーが事前に使用したい正確な形状を知っている場合とは異なります.
今回のように、セルの形状がまだ決まっていない場合を考えてみましょう。
例えば、36原子の4元系等原子比 BCC SQS を生成したいとします。
このとき、可能な限り立方体に近いセルの格子ベクトルを（頭の中で）想像するのは困難です。

この目的を達成するために、以下の手順を踏んでください：
mcsqs -n 36 を実行します。
sqscell.out ファイルが生成されたら、すぐに mcsqs のプロセスを停止してください。
sqscell.out ファイルを整理し、格子ベクトルの長さが等しい（あるいは近い）セル形状だけを残します。
もし等しい長さのセルが複数ある場合は、その中でも最も長さが短いものを選んでください。
なぜなら、それが最も立方体に近い形状を意味するからです。
mcsqs -rc で再スタートします。
手順2は退屈な作業ですので、そのためのPythonコードを作成しました：  
</p>

---

#### POSCAR への変換
<p>
install: c++ ./sqs2poscar.cpp -o ./sqs2poscar </br> 
sqs2poscar 
</p>

---

#### mcsqs の出力ファイル
<p>
sqscell.out, rndstrgrp.out, bestsqs.out, bestcorr.out, mcsqs.log
sqscell.out ファイルについては、以前に紹介しました。
rndstrgrp.out: rndstr.in ファイルを再構成したものです。 
</p>
<p>
<u>bestsqs.out</u> </br>
探索過程で得られた構造のうち, 目的関数が負に最も大きい SQS のみが保存される.
フォーマットは rndstr.in ファイルとほぼ同じだが, bestsqs.out では全てのサイトが
元素の混合状態ではなく, 特定の原子が確定している.
</p>
<p>
<u>bestcorr.out</u>
ターゲットとなる理想ランダム固溶体と, それに対応する bestsqs.out の相関関数が含まれている.
このファイルは5つの列と、最終行の Objective_function で構成されています。
Column 1: n 体相関</br>
Column 2: 計算に含まれる近接原子間の距離</br>
Column 3: SQS の相関関数</br>
Column 4: rndstr.in で定義された合金の相関関数</br>
Column 5: Col. 3 と Col. 4 の差 $\rightarrow$ 理想的な SQS に達するとゼロになる.
意図した通りの近傍シェルを含んでいるか確認する.
例では第 2 近接まで表示されており, 2 つの近接シェルが計算に含まれていることがわかる.
これらの距離の値は、定義された格子定数（1単位）とも一致しています。
最終行: SQS の目的関数（Objective_function）$\rightarrow$
負に大きいほど, その SQS は理想ランダム固溶体とみなすことができる.
すべての相関関数がターゲットと完全に一致した場合, Objective_function
には Perfect_match と表示される.  
</p>
<p>
<u>mcsqs.log</u> </br>
新しい SQS を見つけるたびに,　その目的関数（objective function）と bestcorr.out
の第 5 列にあるすべての数値が保存される.  
</p>
