#### ATAT インストール
<p>
事前に $(HOME)/ATAT/3.50/bin のディレクトリを作っておく.</br>
makefile の BINDIR=$(HOME)/ATAT/3.50/bin にする.</br>
make & make install
</p>

---

#### MAPS（MIT Ab-initio Phase Stability）
<p>
クラスター選択アルゴリズムにより空間的にコンパクトなクラスターを優先的に選び出す.</br> 
ある多体クラスターをクラスター展開に用いる場合は, その低次のクラスター（サブクラスター）
が全て含まれていることが条件. MAPS 以外にも遺伝的アルゴリズムを用いる手法などがある.</br>
Ref. Zarkevich2004_Phys.Rev.Lett.vol92.255702
</p>

---

#### SQS（special quasirandom structure）
<p>
完全ランダム固溶体の相関関数を有限サイズの超格子内で再現するように設計された構造. </br>
</p>
<p>
デフォルトの mcsqs では, 探索過程で得られた構造のうち, 最終的に到達した SQS のみが bestsqs.out
として保存される. そこで, 探索の途中で生成された SQS（完全・不完全を含む）と,
それぞれに対応する相関関数を保存できるように mcsqs のコードを改変する.  
</p>

#### rndstr.in
<p>
corrdump のインプットファイル.
</p>
  
<p>
1 行: 3つのベクトルの長さ（$a, b, c$）と角度（$\alpha, \beta, \gamma$）</br>
$\rightarrow$ デカルト座標系におけるユニットセルを定義する.
POSCAR ファイルのように 3×3 の行列でユニットセルを表す3行の記述に置き換えることも可能.
ユニットセルの目的は, 周期セルとサイトを記述するための座標系を提供すること.
3 - 5 行]: 周期セル（対象とする材料の周期性を表す最小のスーパーセル（基本構造）です。
例えば、FCCのランダム固溶体には1原子のFCCプリミティブセルが必要であり、
HCPのランダム固溶体には2原子のHCPプリミティブセル、
そして$L1_2$合金には4原子のFCCユニットセルが必要となります。]
周期セルはユニットセルを用いて表現されます。
つまり、周期セルのデカルト座標は $B$ と $A$ の積になります。
3番目の部分は、原子濃度を指定した格子サイトです。
周期セル (B) と同様に、Cにおけるサイト座標もユニットセル (A) を用いて表現されます。
つまり、サイトのデカルト座標は $C$ と $A$ の積になります。
各成分の濃度は有効数字 6 桁を超えないようにする.
各サイトにおける濃度の合計は常に 1 にする.  
</p>

<p>
最終的なSQSのサイズや形状は mcsqs が制御するので, 実際の材料の格子定数を記載する必要はない.</br>
これまでのすべての例でも、格子定数には「1」が使用されています。
このように設定しておくことで、後で -2 や -3（クラスターの距離に関するパラメータ）
を指定する際, 判断が容易になる.
</p>

<p>
<u>FCC 型 Cantor 合金</u></br>  
1 1 1 90 90 90</br>
.0 .5 .5</br>
.5 .0 .5</br>
.5 .5 .0</br>
.0 .0 .0 Cr=0.2,Mn=0.2,Fe=0.2,Co=0.2,Ni=0.2</br>
</p>

<p>
<u>L1$_{2}$ FCC 構造の規則合金</u></br>
1 1 1 90 90 90</br>
1 0 0</br>
0 1 0</br>
0 0 1</br>
.0 .0 .0 Cr</br>
.0 .5 .5 Ni=.333333,Fe=.333333,Co=.333334</br>
.5 .0 .5 Ni=.333333,Fe=.333333,Co=.333334</br>
.5 .5 .0 Ni=.333333,Fe=.333333,Co=.333334</br>
</p>

<p>
<u>HCP ランダム固溶体</u></br>
1 1 1.633 90 90 60</br>
1 0 0</br>
0 1 0</br>
0 0 1</br>
.000000 .000000 .0 Ni=.25,Fe=.25,Cr=.25,Co=.25</br>
.666667 .666667 .5 Ni=.25,Fe=.25,Cr=.25,Co=.25</br>
</p>

<p>
<u>D0$_{19}$ HCP 構造の規則合金</u></br>
1 1 1.633 90 90 60</br>
2 0 0</br>
0 2 0</br>
0 0 1</br>
0.000000 0.000000 0.0 Cr</br>
0.000000 1.000000 0.0 Ni=.333333,Fe=.333333,Co=.333334</br>
1.000000 0.000000 0.0 Ni=.333333,Fe=.333333,Co=.333334</br>
1.000000 1.000000 0.0 Ni=.333333,Fe=.333333,Co=.333334</br>
0.666667 0.666667 0.5 Cr</br>
1.666667 0.666667 0.5 Ni=.333333,Fe=.333333,Co=.333334</br>
0.666667 1.666667 0.5 Ni=.333333,Fe=.333333,Co=.333334</br>
1.666667 1.666667 0.5 Ni=.333333,Fe=.333333,Co=.333334</br>
</p>

#### corrdump「-2, -3」パラメータについて
<p>
corrdump コマンドは格子ファイル rndstr.in を読み込み、対称性とクラスターを計算します。
非常に大きな周期セルを定義しない限り、通常このコマンドはすぐに終了します
（大きなセルの場合は clusters.out が巨大になり、数時間以上かかることもあります）。
このコマンドで最も重要なパラメータが -2 です。
これは相関関数を計算する際の**最大距離（カットオフ）**を定義します。
例えば、格子定数を 1 としたFCCランダム固溶体の場合：</br>
第1近接距離：$\frac{\sqrt{2}}{2} \approx 0.71$ </br>
第2近接距離：$1.0$第3近接距離：$\sqrt{1.5} \approx 1.22$ </br>
したがって、第2近接までのペア相関を考慮したい場合は、カットオフ値（-2）を 
1.0 と 1.2 の間の任意の値（例：1.1）に設定します。
-2 と同様に、3体（トリプレット）以上の相関関数には -3 以上のパラメータが使われます。
初心者の多くは、-2, -3 の値の決め方や、何番目の近接シェルまで含めるべきかで迷います。
すべてに当てはまる一般的なルールはありません。
カットオフ値を高く設定するほど、最終的な構造の「無秩序さ（ランダム性）」は向上しますが、
mcsqs コードが完全に一致するSQSを見つけるのに非常に長い時間がかかります。
最善の戦略は、まず低いカットオフ値（例：ペアは2シェルまで、3体は無視）から始め、
良いSQSが得られるまで値を徐々に増やしていくことです。
（良いSQSかどうかの判断基準については後述します）  
</p>

---

#### MCSQS
<p>
定義されたスーパーセルを用いて, モンテカルロ法から SQS を探索する.  
</p>

<p>
SQSに含まれる原子数（XX）は、適切に決定する必要があります。
最低限の条件として、この数値は rndstr.in で定義されたサイト数の倍数であり、
かつ、すべての元素の原子数が整数になるような値でなければなりません。
例えば、3元系の等原子組成 L1${_2}$ 合金（rndstr.in では4サイト）の場合、
SQSには少なくとも12個の原子が含まれている必要があります。
mcsqs コマンドは、材料の複雑さやカットオフ値の設定によっては無限に走り続けることがあります。
通常、カットオフには第2近接シェルまで含めるべきですが、それ以上含める必要はほとんどありません。
なぜなら、もし第2シェルの相関関数の不一致（ミスマッチ）が完璧でない場合、
その誤差がより外側のシェルの誤差を圧倒してしまう可能性が高いからです。
2元系合金の場合、SQSの生成には数秒しかかかりません。
しかし、5元系のランダム合金の場合、完璧なSQSは決して見つからないかもしれず、
「十分に良い」ものを見つけるだけでも数日、あるいは数週間かかることもあります。
ここで言う「十分に良い」の基準は、まさにユーザーの判断次第です。
それは相関関数の最大ミスマッチが 0.1 であることを指すかもしれませんし、0.01 かもしれません。
改訂版の mcsqs を使用している場合、一連の bestsqs-XX.out ファイルが保存されます。
最後に出力されたものが最も相関ミスマッチが小さいですが、
それがその後の研究にとって最良の選択肢であるかどうかは議論の余地があります。
通常、格子ベクトルが非常に長く、ベクトル間の角度が非常に小さいSQSは避けるべきです。
なぜなら、そのような構造はDFT計算を行うモデルとして適していない（計算効率が悪い）からです。  
</p>

#### sqscell.out を用いた探索

<p>
SQSの形状を制御することも可能です。
ここで、もう一つ注意を払うべきファイルがあります。
それが sqscell.out です。
このファイルは mcsqs コマンドによって生成されます。
典型的な sqscell.out の内容は以下の通りです：</br>
2</br>
</br>
 3 -2  4</br>
 3 -4  2</br>
-2  4 -3</br>
</br>
 3  0  0</br>
 0  3  0</br>
-1 -2  2</br>
</p>

<p>
最初の行はセル形状の総数を示し、その後に空行が続きます。次の3行は SQS の1つのセル形状を定義します。
この 3x3 行列はデカルト座標（Cartesian coordinates）を使用しており、
rndstr.in のユニットセルで表現されたものではないことに注意してください。
もし SQS に使用する正確なセルを固定したい場合は、
その格子ベクトルを sqscell.out に記述します。
これにより、mcsqs コマンドにパラメータを追加することで（これは -n xx パラメータを上書きします）、
SQS の生成を制限することができます。:mcsqs -rc  
</p>

<p>
2x2x2のFCCスーパーセル（32原子）を構築する場合、
sqscell.out に記述する行列は非常にシンプルで直感的なものになります。</br>  
1</br>
</br>
2 0 0</br>
0 2 0</br>
0 0 2</br>
</p>

#### Search for SQS with equi-length vectors

<p>
SQSの形状を制御する最も大きな理由は、その形状を可能な限り立方体に近づけることにあります。
これにより、DFT計算において等方的なK点（K-points）の設定が可能になり、
対称性に関連するトラブルも少なくなります。
これは、ユーザーが事前に使用したい正確な形状を知っている場合とは異なります。
今回のように、セルの形状がまだ決まっていない場合を考えてみましょう。
例えば、36原子の4元系等原子比BCC SQSを生成したいとします。
このとき、可能な限り立方体に近いセルの格子ベクトルを（頭の中で）想像するのは困難です。

この目的を達成するために、以下の手順を踏んでください：
mcsqs -n 36 を実行します。
sqscell.out ファイルが生成されたら、すぐに mcsqs のプロセスを停止してください。
sqscell.out ファイルを整理し、格子ベクトルの長さが等しい（あるいは近い）セル形状だけを残します。
もし等しい長さのセルが複数ある場合は、その中でも最も長さが短いものを選んでください。
なぜなら、それが最も立方体に近い形状を意味するからです。
mcsqs -rc で再スタートします。
手順2は退屈な作業ですので、そのためのPythonコードを作成しました：  
</p>

#### Convert SQS to POSCAR

<p>
bestsqs.out ファイルは、rndstr.in と似たフォーマットをしています。
最初の3行（A）は事前に定義したユニットセルです。
続く3行（B）はユニットセルで表現されたSQSの格子ベクトルです。
それに続くすべての行（C）は、ユニットセルで表現された各原子の座標です。
このSQSの出力を POSCAR に変換するには、まず POSCAR の格子ベクトルを $B$ と $A$ の積として計算します。
次に、原子座標を $C$ と $A$ の積として計算します。
ここで注意が必要なのは、bestsqs.out 内の原子は元素ごとにグループ化されていないということです！
必ず元素ごとに並べ替えてください。その後、POSCAR の2行目に実際の格子定数の実験値（Å単位）を入力します。
これで『Cartesian（絶対座標）』形式の POSCAR が得られます。
最後に、この『Cartesian』形式の POSCAR を『Direct（相対座標）』形式に変換することを強く推奨します。
なぜなら、CrystalMakerやVESTAといった可視化ソフトでは後者の方が扱いやすく、
また、高価なリソースを使うDFT計算の前に POSCAR を可視化して確認しておくことは非常に良い習慣だからです。
これもまた退屈な作業のように思えるでしょう。
そのため、この変換を行うC++ツールも作成しました。GitHub（リンク先）に公開しています。  
</p>

#### mcsqs の出力ファイル

<p>
mcsqs は 5 つのファイル（bestsqs-2.out や bestcorr-2.out などを数に含めればそれ以上）を生成します。
それらは、sqscell.out、rndstrgrp.out、bestsqs.out、bestcorr.out、そして mcsqs.log です。
sqscell.out ファイルについては、以前に紹介しました。
rndstrgrp.out ファイルは、単に rndstr.in ファイルを再構成したものです。 
</p>
<p>
<u>bestsqs.out</u> </br>
SQS が保存されるファイル.
そのフォーマットは rndstr.in ファイルと似ていますが、唯一の違いは、bestsqs.out ファイル内のすべてのサイトが、
元素の混合状態ではなく、特定のひとつの原子として確定している点です。
bestsqs.out ファイルを POSCAR に変換するのは容易ですが、それには行列の掛け算と
元素ごとの並べ替え作業が必要になります。
前述の通り、その作業を行うための C++ コードを作成し、GitHub に公開しています。  
</p>
<p>
<u>bestcorr.out</u>
2	0.866025	-0.027778	0.000000	-0.027778</br>
2	0.866025	-0.013889	-0.000000	-0.013889</br>
2	0.866025	0.000000	0.000000	0.000000</br>
2	0.866025	0.027778	0.000000	0.027778</br>
2	0.866025	0.000000	-0.000000	0.000000</br>
2	0.866025	0.000000	0.000000	0.000000</br>
2	1.000000	-0.009259	0.000000	-0.009259</br>
2	1.000000	-0.000000	-0.000000	-0.000000</br>
2	1.000000	-0.018519	0.000000	-0.018519</br>
2	1.000000	-0.027778	0.000000	-0.027778</br>
2	1.000000	0.037037	-0.000000	0.037037</br>
2	1.000000	0.000000	0.000000	0.000000</br>
Objective_function= -0.703988</br>  
</p>
<p>
ターゲットとなる理想ランダム固溶体と, それに対応する bestsqs.out の相関関数が含まれている.
このファイルは5つの列と、最後の一行の『Objective_function（目的関数）』で構成されています。
第1列: その行が「ペア（2体）」なのか「トリプレット（3体）」なのかを示します。例ではペアのみが考慮されています。
第2列: 計算に含まれる近接原子間の距離です。ヒントとして、
ここでコードがあなたの意図した通りのシェル（近傍）を含んでいるか確認できます。
例では第2近接まで表示されており、2つの近接シェルが計算に含まれていることがわかります。
これらの距離の値は、定義された格子定数（1単位）とも一致しています。
第3列: SQSにおける相関関数の結果です。
第4列: rndstr.in で定義されたターゲット合金の相関関数です。
第5列: 第3列と第4列の差（ミスマッチ）です。第5列のすべての数値がゼロになれば、理想的なSQSに達したことになります。
Objective_function にはその SQS の目的関数が表示される.
この値が負に大きいほど, その SQS は理想ランダム固溶体とみなすことができる.
すべての相関関数がターゲットと完全に一致した場合, Objective_function は Perfect_match と表示される.  
</p>
<p>
<u>mcsqs.log</u> </br>
新しい SQS を見つけるたびに, その目的関数（objective function）と bestcorr.out の第5列
にあるすべての数値が保存される. 計算の全体像を把握するのに適したファイルです。  
</p>

---

#### SQS の妥当性
<p>
注目している物性に対して十分な精度があることを検証することで SQS の有効性を確認する.
有効性を保証する目的関数の基準値があるわけではないので,
目的関数が小さな SQS だけが常に有効であるということではない. 
例えば, 目的関数の値が -0.95 の SQS は, -0.85 のものより優れていると判断されるが,
前者の生成に 3 週間かかり, 後者がわずか 5 日で済んだとして, 結果的に両者とも「十分な質」である可能性もある.
数学的な Perfect Match を待つのではなく, 現実的な時間で生成した SQS を使用する（妥協点の見極め）
</p>
<p>
SQS を生成する際、rndstr.in で元素が割り当てられますが、もし2つの元素が「等価」
であれば（つまり、常に同じサイトで同じ濃度を持つ場合）、それらを入れ替えることが可能です。
例えば、等原子比の FCC SQS では、すべての元素が等価であるため、
どの2つの元素も入れ替えることができます。$L1_2$ 型 SQS の場合、
Bサイト（前述の rndstr.in の例では Ni, Co, Fe）にある3つの元素は等価です。
このように等価な元素を入れ替えることで、同じ SQS から複数の「置換パターン（permutation）」を得ることができます。
良い SQS とは、これらすべての置換パターンにおいて、性能（物性値）が近いことが期待されます。
最も本質的な物性は、当然ながら「全自由エネルギー」です。
理想的には、同じ SQS のすべての置換パターンの全自由エネルギーは等しくなります。
しかし、ペアやトリプレットなどの相関関数を、十分に大きなカットオフですべて完璧に一致させることはほぼ不可能であるため、
エネルギーが完全に一致することはまずありません。
置換パターンごとのエネルギーは変動（ゆらぎ）します。
この変動が小さいか大きいかは、材料、セルサイズ、および相関関数に依存します（特に材料の影響が最も顕著です。）。
エネルギーのばらつきがあなたの研究の結論に影響を与えない限り、より膨大な時間をかけて 
SQS を生成し、小さな変動を追求する必要はありません。  
</p>

---

#### Niu2015_Appl.Phys.Lett.vol106.161906
<p>
<u> Fig. 2 で SQS の妥当性を検証</u> </br>
</p>
<p>
この図では、等原子比のNiFeCrCo合金において、「磁気状態（常磁性/強磁性）」と
「元素の並べ替え（Permutation）」が、全エネルギーにどのような影響を与えるかをプロットしています。
エネルギーのばらつき（Energy Scattering）: 同じSQS構造内で、
元素（Ni, Fe, Cr, Co）の配置を入れ替えた複数のパターンについて計算しています。
もしSQSが完璧にランダムであれば、どの入れ替えパターンでもエネルギーは一定になるはずですが、
実際にはわずかにばらつきます。
物理的な結論への影響: 図を見ると、常磁性（DLM）状態でのエネルギーのばらつきに比べ、
特定の磁気的秩序が生まれた際のエネルギー変化の方が支配的であることが示されています。
つまり、「SQSの不完全さに起因する誤差」よりも「調べたい物理現象（磁気駆動の規則化）」
によるエネルギー変化の方が十分に大きいため、
この SQS は研究の結論を導くのに十分な質（Good Enough）であると証明.
不確かさの定量的評価: 元素を入れ替えた複数のパターン（Permutations）で計算を行い、エネルギーの「エラーバー」を明示。
結論のロバスト性: 「SQSの誤差（ノイズ）」と「物理現象（シグナル）」を比較し、シグナルの方が大きいことを確認。  
</p>
<p>
全自由エネルギー以外にも、他の物性を用いて SQS が十分に良いかどうかを判断することができます。
上（原文）に示したのは同じ論文の Fig. 1 です。2つのサブプロットは異なる2つの SQS から得られたものです。
左側は24原子の小さな SQS、右側は120原子の大きな SQS です。
どちらの SQS も同じ FCC ランダム合金を対象としており, 相関関数の設定も同様.
それぞれのサブプロットでは、すべての置換パターンにおける全原子の磁気モーメントを収集し、
局所的な近傍の磁気環境の関数としてプロットしています。右側のサブプロットは原子数が4倍多いため、
プロットの密度が高くなっています。
ここで私が示したいのは、これら2つのサブプロットが同様の傾向を示しているということであり、
これが小さい方の SQS の正確さを証明しています。
</p>

#### Cantor Alloy 

<p>
corrdump -l=rndstr.in -ro -noe -nop -clus -2=1.1 -3=1.1 -4=1.1  
</p>
